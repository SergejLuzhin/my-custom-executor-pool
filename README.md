# Отчёт по проекту

## Краткое описание

В рамках задания реализован собственный пул потоков с поддержкой настройки параметров, логированием, кастомной фабрикой потоков и обработкой перегрузок. Реализация выполняет интерфейс `CustomExecutor`, что делает её совместимой с `Executor` и `CompletableFuture`.

Реализованы:

- Поддержка параметров: `corePoolSize`, `maxPoolSize`, `keepAliveTime`, `queueSize`, `minSpareThreads`
- Система логирования ключевых событий
- Обработка отказов при перегрузке
- Подсчет выполненных и принятых задач
- Грейсфул (`shutdown()`) и немедленный (`shutdownNow()`) режимы завершения
- Жесткое ограничение ресурсов для отказоустойчивости

---

## 1. Исследование параметров производительности

Проведено несколько тестов с задачами, эмулирующими нагрузку (`Thread.sleep(2000)`):

- `corePoolSize = 2`, `maxPoolSize = 4`, `queueSize = 5`  
  → стабильно выполняются 9 задач, остальные отклоняются

- `corePoolSize = 2`, `maxPoolSize = 6`, `queueSize = 10`  
  → позволяет обработать до 16 задач без отказов, при этом нагрузка распределяется равномерно

- `corePoolSize = 4`, `maxPoolSize = 4`, `queueSize = 0`  
  → используется только прямое выполнение задач; хорош для минимальной задержки, но плох при всплесках

Наибольшая производительность достигается при:
- небольшом `corePoolSize` для экономии ресурсов
- достаточном `maxPoolSize` для масштабирования
- умеренном `queueSize`, чтобы не накапливать слишком много задач в памяти

Также важно правильно подобрать `keepAliveTime`, чтобы простаивающие потоки не мешали системе.

---

## 2. Механизм распределения задач и балансировки

В данной реализации используется одна общая очередь задач (`ArrayBlockingQueue`), и задачи не распределяются между несколькими очередями.

Балансировка между потоками происходит за счёт того, что все `Worker`-потоки читают из общей очереди и забирают задачи по мере готовности. Это поведение аналогично pull-модели, когда поток сам выбирает задачу из очереди.

Потоки завершаются, если простаивают дольше `keepAliveTime`, при условии, что общее количество потоков превышает `corePoolSize`.

Резервные потоки (`minSpareThreads`) обеспечивают готовность пула быстро принять новые задачи, даже при слабой текущей нагрузке.

---

## Политика отказа при перегрузке

В случае перегрузки реализована политика отказа: задачи, которые не могут быть приняты из-за переполненной очереди и полной загрузки потоков, отклоняются. Такой подход позволяет жёстко контролировать использование ресурсов и сохранять стабильность системы под высокой нагрузкой. Он делает поведение пула предсказуемым и исключает накапливание задач, что особенно важно для серверных приложений.

---
